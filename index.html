<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Momentum Spinner</title>
<style>
    body {
        background: #222;
        display: flex;
        align-items: center;
        justify-content: center;
        height: 100vh;
        margin: 0;
    }
    canvas {
        background: #fff;
        border-radius: 50%;
    }
</style>
</head>
<body>
<canvas id="spinnerCanvas" width="400" height="400"></canvas>

<script>
class AudioEngine {
    constructor() {
        this.isEnabled = true;
        this.isInitialized = false;
        this.audioContext = null;
        this.masterGain = null;
    }

    init() {
        if (this.isInitialized) return;
        this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
        this.masterGain = this.audioContext.createGain();
        this.masterGain.gain.value = 0.5;
        this.masterGain.connect(this.audioContext.destination);
        this.isInitialized = true;
    }

    createBubblingSound(velocity) {
        if (!this.isEnabled || !this.isInitialized) return null;
        if (this.audioContext.state === 'suspended') this.audioContext.resume();

        const baseFreq = Math.max(100, Math.abs(velocity) * 2 + 200);

        const mainOsc = this.audioContext.createOscillator();
        const mainGain = this.audioContext.createGain();
        mainOsc.type = 'sine';
        mainOsc.frequency.setValueAtTime(baseFreq, this.audioContext.currentTime);

        const volumeLfo = this.audioContext.createOscillator();
        const volumeLfoGain = this.audioContext.createGain();
        volumeLfo.type = 'sine';
        volumeLfo.frequency.setValueAtTime(Math.abs(velocity) * 0.02 + 0.5, this.audioContext.currentTime);
        volumeLfoGain.gain.setValueAtTime(0.5, this.audioContext.currentTime);
        volumeLfo.connect(volumeLfoGain);
        volumeLfoGain.connect(mainGain.gain);

        const freqLfo = this.audioContext.createOscillator();
        const freqLfoGain = this.audioContext.createGain();
        freqLfo.type = 'sine';
        freqLfo.frequency.setValueAtTime(Math.abs(velocity) * 0.05 + 2, this.audioContext.currentTime);
        freqLfoGain.gain.setValueAtTime(baseFreq * 0.2, this.audioContext.currentTime);
        freqLfo.connect(freqLfoGain);
        freqLfoGain.connect(mainOsc.frequency);

        const harmonic = this.audioContext.createOscillator();
        const harmonicGain = this.audioContext.createGain();
        harmonic.type = 'sine';
        harmonic.frequency.setValueAtTime(baseFreq * 2, this.audioContext.currentTime);
        harmonicGain.gain.setValueAtTime(0.15, this.audioContext.currentTime);

        mainOsc.connect(mainGain);
        harmonic.connect(harmonicGain);
        mainGain.connect(this.masterGain);
        harmonicGain.connect(this.masterGain);

        const baseVolume = Math.min(0.3, Math.abs(velocity) / 800);
        mainGain.gain.setValueAtTime(baseVolume, this.audioContext.currentTime);

        const now = this.audioContext.currentTime;
        mainOsc.start(now);
        harmonic.start(now);
        freqLfo.start(now);
        volumeLfo.start(now);

        return { main: mainOsc, harmonic, freqLfo, volumeLfo, mainGain, harmonicGain, freqLfoGain, volumeLfoGain };
    }

    createReverseSound(velocity) {
        if (!this.isEnabled || !this.isInitialized) return null;
        if (this.audioContext.state === 'suspended') this.audioContext.resume();

        const baseFreq = Math.max(80, 800 - Math.abs(velocity) * 3);

        const mainOsc = this.audioContext.createOscillator();
        const mainGain = this.audioContext.createGain();
        mainOsc.type = 'sawtooth';
        mainOsc.frequency.setValueAtTime(baseFreq, this.audioContext.currentTime);

        const volumeLfo = this.audioContext.createOscillator();
        const volumeLfoGain = this.audioContext.createGain();
        volumeLfo.type = 'square';
        volumeLfo.frequency.setValueAtTime(Math.abs(velocity) * 0.03 + 0.5, this.audioContext.currentTime);
        volumeLfoGain.gain.setValueAtTime(0.5, this.audioContext.currentTime);
        volumeLfo.connect(volumeLfoGain);
        volumeLfoGain.connect(mainGain.gain);

        const freqLfo = this.audioContext.createOscillator();
        const freqLfoGain = this.audioContext.createGain();
        freqLfo.type = 'triangle';
        freqLfo.frequency.setValueAtTime(Math.abs(velocity) * 0.08 + 2, this.audioContext.currentTime);
        freqLfoGain.gain.setValueAtTime(-baseFreq * 0.3, this.audioContext.currentTime);
        freqLfo.connect(freqLfoGain);
        freqLfoGain.connect(mainOsc.frequency);

        const subOsc = this.audioContext.createOscillator();
        const subGain = this.audioContext.createGain();
        subOsc.type = 'sine';
        subOsc.frequency.setValueAtTime(baseFreq / 4, this.audioContext.currentTime);
        subGain.gain.setValueAtTime(0.3, this.audioContext.currentTime);

        mainOsc.connect(mainGain);
        subOsc.connect(subGain);
        mainGain.connect(this.masterGain);
        subGain.connect(this.masterGain);

        const baseVolume = Math.min(0.4, Math.abs(velocity) / 800);
        mainGain.gain.setValueAtTime(baseVolume, this.audioContext.currentTime);

        const now = this.audioContext.currentTime;
        mainOsc.start(now);
        subOsc.start(now);
        freqLfo.start(now);
        volumeLfo.start(now);

        return { main: mainOsc, harmonic: subOsc, freqLfo, volumeLfo, mainGain, harmonicGain: subGain, freqLfoGain, volumeLfoGain };
    }

    stopSound(oscillatorGroup) {
        if (!oscillatorGroup) return;
        const now = this.audioContext.currentTime;
        for (let key in oscillatorGroup) {
            if (oscillatorGroup[key] && typeof oscillatorGroup[key].stop === "function") {
                oscillatorGroup[key].stop(now);
            }
        }
    }
}

class MomentumSpinner {
    constructor(canvas) {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d');
        this.center = { x: canvas.width / 2, y: canvas.height / 2 };
        this.radius = Math.min(canvas.width, canvas.height) / 2 - 20;

        this.angle = 0;
        this.velocity = 0;
        this.isDragging = false;
        this.lastMouseAngle = 0;

        this.audioEngine = new AudioEngine();
        this.audioEngine.init();
        this.currentSound = null;

        this.draw();
        this.bindEvents();
    }

    bindEvents() {
        this.canvas.addEventListener('mousedown', e => this.onMouseDown(e));
        this.canvas.addEventListener('mousemove', e => this.onMouseMove(e));
        this.canvas.addEventListener('mouseup', e => this.onMouseUp(e));
        this.canvas.addEventListener('mouseleave', e => this.onMouseUp(e));
    }

    getMouseAngle(e) {
        const rect = this.canvas.getBoundingClientRect();
        const x = e.clientX - rect.left - this.center.x;
        const y = e.clientY - rect.top - this.center.y;
        return Math.atan2(y, x);
    }

    onMouseDown(e) {
        this.isDragging = true;
        this.lastMouseAngle = this.getMouseAngle(e);
        this.velocity = 0;
        this.audioEngine.stopSound(this.currentSound);
        this.currentSound = null;
    }

    onMouseMove(e) {
        if (!this.isDragging) return;
        const angle = this.getMouseAngle(e);
        let delta = angle - this.lastMouseAngle;
        if (delta > Math.PI) delta -= Math.PI * 2;
        if (delta < -Math.PI) delta += Math.PI * 2;

        this.angle += delta;
        this.velocity = delta * 1000; 
        this.lastMouseAngle = angle;
        this.draw();
    }

    onMouseUp(e) {
        if (!this.isDragging) return;
        this.isDragging = false;
        this.startSpinning();
    }

    startSpinning() {
        this.audioEngine.stopSound(this.currentSound);
        if (this.velocity >= 0) {
            this.currentSound = this.audioEngine.createBubblingSound(this.velocity);
        } else {
            this.currentSound = this.audioEngine.createReverseSound(this.velocity);
        }
        requestAnimationFrame(() => this.spinLoop());
    }

    spinLoop() {
        this.angle += this.velocity / 1000;
        this.velocity *= 0.98; 

        if (Math.abs(this.velocity) < 0.01) {
            this.velocity = 0;
            this.audioEngine.stopSound(this.currentSound);
            this.currentSound = null;
            return;
        }
        this.draw();
        requestAnimationFrame(() => this.spinLoop());
    }

    draw() {
        const ctx = this.ctx;
        ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        ctx.save();
        ctx.translate(this.center.x, this.center.y);
        ctx.rotate(this.angle);

        ctx.beginPath();
        ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
        ctx.fillStyle = '#66c2ff';
        ctx.fill();
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(this.radius, 0);
        ctx.strokeStyle = '#003366';
        ctx.lineWidth = 5;
        ctx.stroke();

        ctx.restore();
    }
}

const canvas = document.getElementById('spinnerCanvas');
new MomentumSpinner(canvas);
</script>
</body>
</html>
